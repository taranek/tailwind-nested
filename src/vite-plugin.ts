import { writeFileSync } from 'fs';
import { resolve } from 'path';
import type { Plugin } from 'vite';

/**
 * Vite plugin to transform twn calls and expose classes to Tailwind via CSS @source inline
 * This plugin extracts all classes from twn() function calls and generates a CSS file
 * with @source inline() directive for Tailwind v4 to scan.
 */
export function twnPlugin(): Plugin {
  const classesSet = new Set<string>();
  let lastWrittenContent = '';
  
  return {
    name: 'twn-plugin',
    enforce: 'pre', // Run before other plugins (including Tailwind)
    
    transform(code: string, id: string) {
      // Only process TypeScript/JavaScript files
      if (!/\.(ts|tsx|js|jsx)$/.test(id)) {
        return null;
      }

      // Look for twn calls
      const twnRegex = /twn\s*\(\s*[`'"]([^`'"]*)[`'"](?:\s*,\s*\{([^}]*)\})?\s*\)/g;

      let match: RegExpExecArray | null;

      while ((match = twnRegex.exec(code)) !== null) {
        const [, baseClasses, selectorContent] = match;

        try {
          // Add base classes
          if (baseClasses) {
            const baseClassList = baseClasses.split(/\s+/).filter(cls => cls.length > 0);
            baseClassList.forEach(cls => classesSet.add(cls));
          }

          // Parse selector object and collect classes
          if (selectorContent) {
            parseSelectorsObject(selectorContent, classesSet);
          }
        } catch (error) {
          console.warn('Failed to parse twn call:', (error as Error).message);
        }
      }

      // Generate CSS file with @source inline for Tailwind scanning
      if (classesSet.size > 0) {
        const classesArray = Array.from(classesSet);
        const newContent = classesArray.join(' ');
        
        if (newContent !== lastWrittenContent) {
          const cssFile = resolve(process.cwd(), 'src', 'twn-classes.css');
          const cssContent = `/* Auto-generated by twn plugin - DO NOT EDIT */
@source inline("${newContent}");
`;
          writeFileSync(cssFile, cssContent);
          lastWrittenContent = newContent;
        }
      }

      return null; // Don't transform the code, just collect classes
    }
  };
}

function parseSelectorsObject(selectorContent: string, classesSet: Set<string>): void {
  // Parse nested object structure
  const parseLevel = (content: string, prefix = ''): void => {
    // Match key-value pairs at current level
    const propRegex = /['"]?([^'":,\s{}]+)['"]?\s*:\s*(?:['"]([^'"]*)['"']|\{([^{}]*)\})/g;
    let match: RegExpExecArray | null;

    while ((match = propRegex.exec(content)) !== null) {
      const [, key, stringValue, objectValue] = match;

      if (stringValue !== undefined) {
        // Handle string values
        const currentPrefix = prefix ? `${prefix}:${key}` : key;
        const classes = stringValue.split(/\s+/).filter(cls => cls.length > 0);
        
        classes.forEach(cls => {
          if (key === '&') {
            // Special case for '&' - use prefix without the key
            classesSet.add(`${prefix}:${cls}`);
          } else {
            classesSet.add(`${currentPrefix}:${cls}`);
          }
        });
      } else if (objectValue !== undefined) {
        // Handle nested objects
        const currentPrefix = prefix ? `${prefix}:${key}` : key;
        parseLevel(objectValue, currentPrefix);
      }
    }
  };

  parseLevel(selectorContent);
}